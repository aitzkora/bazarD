\documentclass[11pt,a4wide]{article}

\usepackage{amsmath,amssymb,amsfonts}
\usepackage{graphicx}
\newcommand{\tiret}{\rule[0.6ex]{1.3ex}{0.22ex}}

% !! pour le francais
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{listings}
\usepackage{relsize}
\usepackage{color}
\usepackage{fancyvrb}
\usepackage{punk}
\usepackage{emerald}

\newcommand{\fleche}{\alert{$\pmb{\longrightarrow}$}~~}
\newcommand{\calM}{{\mathcal{M}}}


%%%%% for smiley
\def\mysmile#1{{\ooalign{\hfil\lower.06ex % a smiley face
 \hbox{$\scriptscriptstyle#1$}\hfil\crcr
 \hfil\lower.7ex\hbox{\"{}}\hfil\crcr
 \mathhexbox20D}}}


\newcommand{\bad}{\bf \textcolor{red}{\mysmile \frown}}
\newcommand{\neutral}{\bf \textcolor{blue}{\mysmile \minus}}
\newcommand{\good}{\bf \textcolor{green}{\mysmile \smile}}

\newcommand{\calU}{{\mathcal{U}}}
\newcommand{\Cau}{\mathcal{C}_{n+1}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Sym}[1]{\mathcal{S}_{#1}(\R)}
\newcommand{\tran}{^{\top}}
\newcommand{\pssg}{\langle \langle}
\newcommand{\pssd}{\rangle \rangle}
\newcommand{\aronde}{\mathcal{A}}
\newcommand{\Tr}{\mathtt{Tr}}
\newcommand{\accol}[1]{{\left\{ \begin{array}{ll} #1 \end{array} \right.}}
\newcommand{\prods}[2]{\langle #1,#2 \rangle}
\newcommand{\Aa}{\mathcal{A}}
\newcommand{\norm}[1]{\|#1\|}
\newcommand{\matlab}{{\ECFTeenSpirit Malab}\ }
\newcommand{\python}{{\bf Python}\ }
\newcommand{\numpy}{{\bf Numpy}\ }
\newcommand{\scipy}{{\bf Scipy}\ }
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstset{ %
  language=python,                % the language of the code
  framerule=0pt,
  basicstyle=\relsize{-2}\ttfamily,  % the size of the fonts that are used for the code
  %backgroundcolor=\color{black!10},  % choose the background color. You must add \usepackage{color}
  showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  showtabs=false,                 % show tabs within strings adding particular underscores
  %frame=single,                   % adds a frame around the code
  rulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))
  breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
  keywordstyle=\color{blue},      % keyword style
  commentstyle=\color{dkgreen},   % comment style
  stringstyle=\color{mauve}  
}

\newcommand{\guill}[1]{``#1''} % attention deja dans mycv


\title{Comment utiliser \python comme alternative à \matlab}
\begin{document}
\maketitle
\section{Introduction}
  Le but de TP est de vous apprendre à utiliser \python comme outil de prototypage rapide en calcul numérique - au
  même titre que \matlab.
  Pour ce projet, nous allons principalement utiliser 2 modules (ou bibliothèques) d'extension de \python qui
  permettent de faire du calcul numérique, respectivement \numpy et \scipy.

  \subsection{Quelques differences notables avec \matlab}
    \begin{itemize}
      
      \item les indices des ``tranches'' commencent toujours à zéro et ne contiennent pas le dernier élément : 
      \begin{lstlisting} 
      a=np.zeros((4,3))
      all(a[0:4,1]==a[:,1]) % renvoies True
      all(
      \end{lstlisting}
      \item le dernier élément d'une dimension peut etre atteint au travers de l'indice -1 (équivalent de end en \matlab)
      \item Attention \python utilise des références : 
      \begin{lstlisting} 
      a = np.zeros(4); b=a; b[1] = 10; a[1]
      \end{lstlisting}
      renvoie 10 et non pas zéro!
      \item Pour copier un objet, on utilise {\tt .copy()} : ainsi 
      \begin{lstlisting} 
      a = np.zeros(4); b=a.copy(); b[1] = 10; a[1]
      \end{lstlisting}
      renvoie 0.0 
      
      \item \python autorise le {\em broadcast} des matrices de dimensions differentes lors d'opérations terme à terme : en clair,
      si 2 matrices(ou tableaux ND) ont une (ou plusieurs) dimensions differentes et que ces dimensions sont égales à 1 dans
      pour un des deux membres alors le tableau est duplique dans cette dimension pour la faire correspondre avec l'autre. 
      Exemple : 
      \begin{lstlisting} 
       a=np.random.rand(10,3) % a est de dimension 10x3
       m=np.mean(a,0) % est de dimension 3
      \end{lstlisting}

  \subsection{Quelques recommendations de programmation}
 
    \begin{itemize}

      \item eviter le plus possible les boucles $\Rightarrow$ penser vectoriel
      \item allouer les structures de données avant d'écrire dedans : \lstinline!a=np.zeros(1000);!
      \item éventuellement désallouer la mémoire qui n'est plus utilisée ({\tt del}) ; \python 
      a un ramasse-miettes intégré, mais on peut l'aider({\good})
      \item Faire des imports avec des noms : 
      \begin{lstlisting}
      import numpy as np
      import scipy as sp
      \end{lstlisting}
      \item écrire des tests (doctests, unittest ou nose). Dans ce TP on utilisera les premiers. Exemple pour verifier le résultat d'une fonction
      \begin{lstlisting}
      """
      >>> mafonction(5)
      3
      """
      \end{lstlisting}
      en supposant que {\tt mafonction(5)} renvoies normalement 3.

      \item écrire de la doc (docstring) :  

    \end{itemize}

\section{Mini-projet}

   Nous allons attaquer un probléme classique sous plusieurs angles : on va résoudre l'équation de la chaleur avec
   un schéma aux differences finies. L'interêt n'est pas dans les mathématiques mis en \oe uvres mais plutôt
   de manipuler des matrices avec \numpy et \scipy

   \subsection{préambule mathématique}
    
   le but est de résoudre l'équation suivante, 
$$
\begin{cases} 
\frac{\partial u}{\partial t} - c \Delta u = 0 \\
u(x,t) = 1 \, \qquad \forall  t \in [0,T] \qquad \,  \forall x \in \partial \Omega
\end{cases}
$$
sur le domaine $\Omega = [0,1]^2$.
On discrétise la dérivée en temps par un schéma d'ordre un :
$$
\frac{\partial u}{\partial t}(x,t_k) \approx \frac{u(x, t_k + dt) - u(x, t_k)}{dt}
$$
et le laplacien ($\Delta u$) est discrétisé en espace sous la forme suivante 
$$
u(x,y) \approx \frac{u(x-h_x, y) + u(x+ h_x, y) - 2 u(x,y)}{h_x^2} +  \frac{u(x, y-h_y) + u(x, y + h_y) - 2 u(x,y)}{h_y^2} 
$$
On arrive donc au schéma suivant, 
\begin{equation}\label{Chal}
U^{n+1}_{i,j} =  w_x \left[U^n_{i-1, j} + U^n_{i+1, j} + \left(\frac{c}{w_x}-2\right) U^n_{i,j} \right] 
             + w_y \left[U^n_{i,j-1} + U^n_{i, j+1} + \left(\frac{c}{2w_y}-2\right)U^n_{i,j} \right]
\end{equation}
avec $w_x = \frac{dt}{h_x^2}$ et $w_y = \frac{dt}{h_y^2}$

 \end{itemize}
 
   \subsection{Algebre lineaire dense}

    On va construire l'opérateur laplacien sous forme d'une matrice dense : on notera dans la suite
$$
K(n) = \begin{pmatrix}
       2       & -1      & 0 \\
       -1      &  \ddots & -1 \\
       {\bf 0} & -1      & 2 \\
       \end{pmatrix}
$$
alors le laplacien 2D se construit sous la forme suivant
$$
{\mathcal H}(n_x,n_y) = \frac{1}{h_x^2} K(n_x) \otimes I_{n_y} + \frac{1}{h_y^2} I_{n_x} \otimes  K_(n_y) 
$$

   \subsection{Questions}
     
      \begin{enumerate}

        \item Faire une fonction {\tt K1D} qui prend un entier $n$ en argument et construit la matrice $K(n)$, on pourra utiliser {\tt diag}
	\item ajouter les doctest suivants sur {\tt K1D}
	\begin{lstlisting}
>>> np.diag(K1D(4)).tolist()
[2.0, 2.0, 2.0, 2.0]
>>> np.diag(K1D(3),-1).tolist()
[-1.0, -1.0]
>>> np.diag(K1D(4),1).tolist()
[-1.0, -1.0, -1.0]
	\end{lstlisting}
      et rajouter 
    \begin{lstlisting}
if __name__ == "__main__":
    import doctest
    doctest.testmod() 
    \end{lstlisting}
    pour executer les doctests
    \item coder une fonction {\tt laplacien\_2D} qui construit ${\mathcal H}(n_x,n_y)$; penser à utiliser {\tt kron}
                 
     \end{enumerate}




\end{document}
